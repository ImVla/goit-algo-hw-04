Для набору даних розміром 100 елементів:
Випадкові дані:
Сортування вставками: 0.0053 с
Сортування злиттям: 0.0003 с
Timsort: 0.00002 с
Відсортовані дані:
Сортування вставками: 0.00002 с
Сортування злиттям: 0.0002 с
Timsort: 0.000005 с
Зворотньо відсортовані дані:
Сортування вставками: 0.00055 с
Сортування злиттям: 0.0002 с
Timsort: 0.00001 с
Для набору даних розміром 1000 елементів:
Випадкові дані:
Сортування вставками: 0.180 с
Сортування злиттям: 0.0125 с
Timsort: 0.00017 с
Відсортовані дані:
Сортування вставками: 0.0002 с
Сортування злиттям: 0.0029 с
Timsort: 0.000025 с
Зворотньо відсортовані дані:
Сортування вставками: 0.137 с
Сортування злиттям: 0.0051 с
Timsort: 0.00009 с
Для набору даних розміром 10000 елементів:
Випадкові дані:
Сортування вставками: 8.63 с
Сортування злиттям: 0.134 с
Timsort: 0.0036 с
Відсортовані дані:
Сортування вставками: 0.013 с
Сортування злиттям: 0.065 с
Timsort: 0.00027 с
Зворотньо відсортовані дані:
Сортування вставками: 15.51 с
Сортування злиттям: 0.066 с
Timsort: 0.0011 с
Висновки:
Timsort показує значно кращу продуктивність порівняно з іншими алгоритмами у більшості випадків, особливо на великих масивах. Це підтверджує його ефективність для реальних задач.
Сортування злиттям ефективніше за сортування вставками на більших наборах даних, але все одно поступається Timsort.
Сортування вставками показує хороші результати на вже відсортованих масивах, але є непрактичним для випадкових або зворотньо відсортованих великих масивів.
Ці результати підтверджують, що об'єднання стратегій сортування злиттям та вставками в Timsort робить його дуже ефективним і рекомендованим вибором для загального використання в Python. ​
